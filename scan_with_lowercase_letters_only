import itertools
import json
import string
from multiprocessing import Pool, Manager
from bip_utils import Bip39SeedGenerator, Bip84, Bip84Coins, Bip44Changes
import time
import keyboard

def create_native_segwit_address(mnemonic_words, passphrase=''):
    seed_bytes = Bip39SeedGenerator(mnemonic_words).Generate(passphrase=passphrase)
    bip84_ctx = Bip84.FromSeed(seed_bytes, Bip84Coins.BITCOIN)
    address = bip84_ctx.Purpose().Coin().Account(0).Change(Bip44Changes.CHAIN_EXT).AddressIndex(0).PublicKey().ToAddress()
    return address

def generate_passphrases_and_check_address(mnemonic_words, target_address, passphrases, result_dict):
    for passphrase in passphrases:
        address = create_native_segwit_address(mnemonic_words, passphrase)
        result_dict['last_tried'] = passphrase
        if address == target_address:
            result_dict['found'] = True
            result_dict['passphrase'] = passphrase
            result_dict['address'] = address
            break

def read_state():
    try:
        with open("state.json", "r") as file:
            state = json.load(file)
        if "length" in state and type(state["length"]) is int and state["length"] >= 6:
            return state
        else:
            return {"length": 6, "last_passphrase": ""}
    except FileNotFoundError:
        return {"length": 6, "last_passphrase": ""}

def save_state(length, last_passphrase):
    with open("state.json", "w") as file:
        json.dump({"length": length, "last_passphrase": last_passphrase}, file)

def main():
    words = "blossom educate state course sick fresh color divide number soap please pull glide weather join grit depart dynamic tenant leopard alter piano slight room"
    target_address = "bc1qcyrndzgy036f6ax370g8zyvlw86ulawgt0246r"
    state = read_state()
    characters = string.ascii_lowercase

    num_cores = int(input("Please enter the number of processor cores to use: "))
    chunk_size = 10000  # Adjust size based on your system's capabilities

    manager = Manager()
    result_dict = manager.dict({'found': False, 'last_tried': state['last_passphrase'], 'passphrase': '', 'address': ''})

    pool = Pool(processes=num_cores)
    print(f"Using {num_cores} worker processes")

    try:
        length = state["length"]
        last_time = time.time()

        while not result_dict['found']:
            all_passphrases = (''.join(p) for p in itertools.product(characters, repeat=length))
            while True:
                chunk = list(itertools.islice(all_passphrases, chunk_size))
                if not chunk:
                    break
                pool.apply_async(generate_passphrases_and_check_address, args=(words, target_address, chunk, result_dict))
            pool.close()
            pool.join()

            if result_dict['found']:
                print(f"Match found! Passphrase: {result_dict['passphrase']}, Address: {result_dict['address']}")
                return
            
            if time.time() - last_time >= 5:
                print(f"Last passphrase tried: {result_dict['last_tried']}")
                last_time = time.time()
            
            if keyboard.is_pressed('p'):
                print("Pause requested by user.")
                save_state(length, result_dict['last_tried'])
                return

            length += 1
            save_state(length, '')

    finally:
        if pool:
            pool.terminate()

if __name__ == '__main__':
    main()
